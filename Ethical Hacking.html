<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ethical Hacking</title>

    <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-python.min.js"></script>
    <script>
        function toggleDarkMode() {
            document.body.classList.toggle("dark-mode");
            document.querySelector(".container").classList.toggle("dark-mode");
            document.querySelector("pre").classList.toggle("dark-mode");
            localStorage.setItem("darkMode", document.body.classList.contains("dark-mode"));
        }
        window.onload = () => {
            if (localStorage.getItem("darkMode") === "true") {
                document.body.classList.add("dark-mode");
                document.querySelector(".container").classList.add("dark-mode");
                document.querySelector("pre").classList.add("dark-mode");
            }
        };
    </script>

    <style>
        body {
            font-family: Arial, sans-serif; margin: 20px; padding: 20px;
            background: #f4f4f4; color: #333; transition: 0.3s;
        }
        .container {
            max-width: 800px; margin: auto; background: white; padding: 20px;
            border-radius: 10px; box-shadow: 0 0 10px rgba(0,0,0,0.1); transition: 0.3s;
        }
        pre { background: #333; color: #fff; padding: 10px; border-radius: 5px; overflow-x: auto; }
        img { max-width: 100%; height: auto; border-radius: 5px; }
        body.dark-mode { background: #121212; color: #f4f4f4; }
        .container.dark-mode { background: #1e1e1e; box-shadow: 0 0 10px rgba(255,255,255,0.1); }
        pre.dark-mode { background: #444; }
        .dark-mode-toggle {
            position: absolute; top: 20px; right: 20px; font-size: 24px; cursor: pointer; background: none; border: none; transition: 0.3s;
        }
        .dark-mode-toggle span { color: gray; transition: 0.3s; }
        .dark-mode-toggle:hover span { color: darkgray; }
        .dark-mode .dark-mode-toggle span { color: lightgray; }
    </style>
</head>
<body>

<button class="dark-mode-toggle" onclick="toggleDarkMode()"><span>☽︎</span></button>

<div class="container">
    <h1 style="text-align: center;">OWASP Top 10 in Python-Based Development Framework</h1><br>

    <h2>Introduction</h2>
    <p>Web applications play a crucial role in modern digital infrastructure but are also prime targets for cyber threats. Security vulnerabilities can lead to data breaches, financial losses, service disruptions, and a loss of user trust. This project provides a <strong>comprehensive analysis of the OWASP Top 10 vulnerabilities</strong> within a <strong>Django-based web application,</strong> demonstrating their impact and mitigation strategies.</p>
    <p>The project follows a structured approach by intentionally implementing <strong>security flaws,</strong> showcasing their exploitation, and applying remediation techniques. This hands-on analysis enhances understanding of common security risks in Python-based web development.</p>
    <p>By highlighting real-world attack scenarios and secure coding practices, this research serves as an educational resource for building resilient and secure Django applications.</p>
    <p>The following vulnerabilities are covered in detail:</p>
    <ol>
        <li><em> SQL Injection (SQLi)</em></li>
        <li><em> Cross-Site Scripting (XSS)</em></li>
        <li><em> Broken Authentication</em></li>
        <li><em> Insecure Deserialization</em></li>
        <li><em> Security Misconfiguration</em></li>
        <li><em> Cross-Site Request Forgery (CSRF)</em></li>
        <li><em> Server-Side Request Forgery (SSRF)</em></li>
        <li><em> Insufficient Logging & Monitoring</em></li>
        <li><em> XML External Entity (XXE) Injection</em></li>
        <li><em> Broken Access Control</em></li>
    </ol>


    <br><h2>Required Hardware/Software</h2>
    <p><strong>Hardware:</strong> A standard computer capable of running Python and Django. It is recommended to provide a minimum of 8 GB RAM and 50 GB of available disk space for development and testing.</p>
    <p><strong>Software:</strong></p>
    <ul>
        <li>Python 3.10 - required for running Django and handling the backend logic.</li>
        <li>Django - the web framework used to build the application.</li>
        <li>SQLite - default database for development.</li>
        <li>PyCharm - recommended IDE for Python/Django development.</li>
        <li>Dependencies - managed in <strong><code>requirements.txt</code></strong> to ensure consistency</li>
    </ul>
    <p><strong>Security Considerations:</strong> Develop in a virtual environment <strong><code>(venv)</code></strong> and thoroughly test the application on a local server to avoid system conflicts, security risks, and unintended vulnerabilities, while ensuring that all essential security best practices, including Django's built-in settings, are properly implemented and tested before any live deployment to a production environment.</p>


    <br><h2>Detailed Instructions</h2>
    <h3>1. Environment Setup</h3>
    <p><strong>Step 1: Clone the Repository</strong> - to get started, clone the GitHub repository where I've added the project:</p>
    <p style="text-align: center;">
        <code style="font-weight: bold;">
            git clone https://github.com/VenharAdemi/EthicalHacking.git <br>
            cd EthicalHacking
        </code>
    </p>
    <p><strong>Step 2: Create and Activate a Virtual Environment</strong> - next, create a virtual environment to isolate the project dependencies:</p>
    <p style="text-align: center;">
        <code style="font-weight: bold;">
            python3 -m venv venv
        </code>
    </p>
    <p>Activate the virtual environment:</p>
    <p style="text-align: center;">
        <code style="font-weight: bold;">
            venv\Scripts\activate
        </code>
    </p>
    <p><strong>Step 3: Install Dependencies</strong> - install the required dependencies listed in the requirements.txt file:</p>
    <p style="text-align: center;">
        <code style="font-weight: bold;">
            pip install -r requirements.txt
        </code>
    </p>
    <p>Additionally, if any dependencies like requests or lxml are missing, install them manually:</p>
    <p style="text-align: center;">
        <code style="font-weight: bold;">
            pip install requests lxml
        </code>
    </p>
    <p><strong>Step 4: Apply Migrations and Run the Server</strong> - now, apply the database migrations to set up the project’s database:</p>
    <p style="text-align: center;">
        <code style="font-weight: bold;">
            python manage.py makemigrations <br>
            python manage.py migrate
        </code>
    </p>
    <p>Finally, start the development server:</p>
    <p style="text-align: center;">
        <code style="font-weight: bold;">
            python manage.py runserver
        </code>
    </p>
    <p>You can now visit the Django application at <strong><code>http://127.0.0.1:8000/</code></strong> in your browser.</p>
    <p>This setup ensures you have all dependencies installed and the environment correctly configured to run the Django project. Since I’ve added the project to GitHub, you can easily follow these steps to get the code running locally. You can access the repository at: <a href="//github.com/VenharAdemi/EthicalHacking.git">https://github.com/VenharAdemi/EthicalHacking.git</a></p>

    <br><h3>2. Implementing the Vulnerabilities</h3>
    <p>In this section, we will implement the OWASP Top 10 vulnerabilities in a Django-based web application. These vulnerabilities will be intentionally included to help you understand how attackers exploit them and how they can be mitigated.</p>
    <h4>2.1 SQL Injection (SQLi)</h4>
    <p>SQL injection occurs when user input is directly inserted into an SQL query, which can allow attackers to manipulate the query and access sensitive data. In this example, we will demonstrate a vulnerable <strong><code>search</code></strong> function.</p>
    <p><strong>Implementation:</strong> in the <strong><code>views.py</code></strong> file, implement the SQL injection vulnerability in the <strong><code>search</code></strong> function.</p>
    <pre><code class="language-python">
# 1. SQL Injection - Directly injecting SQL via user input
def search(request):
    query = request.GET.get('q', '')  # Get search query from GET request
    results = []
    if query:  # Only execute SQL if there's a search query
        sql = f"SELECT id, title, content FROM ethicalHacking_post WHERE title LIKE '%{query}%'"
        print(f"Executing SQL: {sql}")  # Debugging output
        with connection.cursor() as cursor:
            cursor.execute(sql)  # Vulnerable to SQL Injection
            results = cursor.fetchall()  # Fetch all results
    return render(request, "search.html", {"query": query, "results": results})
    </code></pre>
    <p><strong>Exploitation Example:</strong> visit the following URL in your browser: <strong><code>http://127.0.0.1:8000/search?q=' OR 1=1 --</code></strong><br>
        This would cause the query to always return true <strong><code>(1=1)</code></strong>, potentially exposing all records in the database.</p><br><hr><br>
    <h4>2.2 Cross-Site Scripting (XSS)</h4>
    <p>XSS occurs when an attacker injects malicious scripts into a webpage viewed by others. This is often done by including harmful JavaScript through user input.</p>
    <p><strong>Implementation:</strong> in the <strong><code>views.py</code></strong> file, create a vulnerable <strong><code>comment</code></strong> view that directly renders user input:</p>
    <pre><code class="language-python">
# 2. XSS - Rendering user input directly in templates
def comment(request):
    comment = request.GET.get("comment", "")
    return HttpResponse(f"User Comment: {comment}")
    </code></pre>
    <p><strong>Exploitation Example:</strong> visit the following URL to inject a malicious script: <strong><code>http://127.0.0.1:8000/comment?comment=&quot;&lt;script&gt;alert('XSS')&lt;/script&gt;&quot;</code></strong><br>
        The script would execute when the comment is rendered on the page.</p><br><hr><br>
    <h4>2.3 Broken Authentication</h4>
    <p>Broken authentication happens when passwords or other sensitive data are not securely stored or handled. Here, we demonstrate a vulnerable registration form that stores passwords in plain text.</p>
    <p><strong>Implementation:</strong> in the <strong><code>views.py</code></strong> file, create a <strong><code>register </code></strong> function that stores the password insecurely:</p>
    <pre><code class="language-python">
# 3. Broken Authentication - Storing plain-text passwords
def register(request):
    if request.method == "POST":
        form = RegisterForm(request.POST)
        if form.is_valid():
            username = form.cleaned_data["username"]
            # Storing in plain text (INSECURE)
            password = form.cleaned_data["password"]
            # Directly storing the plain-text password
            user = UserPost(username=username)
            # No hashing!
            user.password = password
            user.save()
            return HttpResponse("User registered successfully (INSECURE)")
    else:
        form = RegisterForm()
    return render(request, "register.html", {"form": form})
    </code></pre>
    <p><strong>Exploitation Example:</strong> you can now register users with the password in plain text, and an attacker could easily access and read it from the database.</p><br><hr><br>
    <h4>2.4 Insecure Deserialization</h4>
    <p>Insecure deserialization happens when untrusted data is deserialized, which can lead to arbitrary code execution. Here, we use <strong><code>pickle.loads()</code></strong> on user-controlled data.</p>
    <p><strong>Implementation:</strong> in the <strong><code>views.py</code></strong> file, create a vulnerable <strong><code>deserialize_data</code></strong> view:</p>
    <pre><code class="language-python">
# 4. Insecure Deserialization - Using `pickle.loads()` on user input
def deserialize_data(request):
    data = request.GET.get('data')
    try:
        decoded_data = base64.b64decode(data) # Decode the Base64 string into bytes
        obj = pickle.loads(decoded_data) # Unpickle the decoded data
        return HttpResponse(f"Deserialized object: {obj}")
    except Exception as e:
        # Handle errors
        return HttpResponse(f"Error deserializing data: {str(e)}", status=500)
    </code></pre>
    <p><strong>Exploitation Example:</strong> send a crafted Base64-encoded <strong><code>pickle</code></strong> payload: <strong><code>http://127.0.0.1:8000/deserialize/?data=&lt;Base64-encoded-malicious-pickle&gt;</code></strong><br>
        This could execute arbitrary code on the server if the payload is crafted correctly.</p><br><hr><br>
    <h4>2.5 Security Misconfiguration</h4>
    <p>Security misconfiguration occurs when security settings are not correctly applied. In Django, this could mean having debug mode enabled or improper allowed hosts settings.</p>
    <p><strong>Implementation:</strong> in the <strong><code>settings.py</code></strong>, enable the following dangerous configurations (typically found in development environments):</p>
    <pre><code class="language-python">
# 5. Security Misconfiguration - DEBUG mode and open ALLOWED_HOSTS
DEBUG = True  # Should be False in production
ALLOWED_HOSTS = ['*']  # Open to all hosts (should specify trusted hosts in production)
    </code></pre>
    <p><strong>Exploitation Example:</strong> attackers could easily take advantage of these settings by exploiting weak or default configurations to attack the server.</p><br><hr><br>
    <h4>2.6 Cross-Site Request Forgery (CSRF)</h4>
    <p>CSRF allows attackers to make requests on behalf of authenticated users without their consent. Here, we will disable CSRF protection on a vulnerable endpoint.</p>
    <p><strong>Implementation:</strong> in the <strong><code>views.py</code></strong> file, disable CSRF protection for the <strong><code>transfer_money</code></strong> view:</p>
    <pre><code class="language-python">
# 6. CSRF - Disabling CSRF protection
from django.views.decorators.csrf import csrf_exempt
@csrf_exempt
def transfer_money(request):
    if request.method == "POST":
        amount = request.POST.get("amount")
        # Add logic to handle the transfer of the specified amount
        return HttpResponse(f"Transferred {amount} successfully!")
    return render(request, "transfer.html")
    </code></pre>
    <p><strong>Exploitation Example:</strong> an attacker could send a POST request from an external site to transfer funds from an authenticated user without their knowledge.</p><br><hr><br>
    <h4>2.7 Server-Side Request Forgery (SSRF)</h4>
    <p>SSRF occurs when an attacker can make requests from the server to internal resources, potentially exposing sensitive information.</p>
    <p><strong>Implementation:</strong> in the <strong><code>views.py</code></strong> file, allow users to input arbitrary URLs to fetch data:</p>
    <pre><code class="language-python">
# 7. SSRF - Allowing user-supplied URLs without validation
def fetch_data(request):
    url = request.GET.get("url")
    if not url:
        return JsonResponse({"error": "Missing URL parameter"}, status=400)
    try:
        response = requests.get(url)
        return HttpResponse(f"Fetched data from {url}: {response.text}")
    except requests.exceptions.MissingSchema:
        return JsonResponse({"error": "Invalid URL format. Must include http:// or https://"}, status=400)
    except requests.exceptions.RequestException as e:
        return JsonResponse({"error": f"Request failed: {str(e)}"}, status=500)
    </code></pre>
    <p><strong>Exploitation Example:</strong> visit the following URL to trigger an internal request: <strong><code>http://127.0.0.1:8000/fetch_data?url=http://localhost:8080/secret</code></strong></p><br><hr><br>
    <h4>2.8 Insufficient Logging & Monitoring</h4>
    <p>Lack of logging and monitoring makes it harder to detect and respond to attacks. Here, we implement a login attempt view without logging failed attempts.</p>
    <p><strong>Implementation:</strong> in the <strong><code>views.py</code></strong> file, create a vulnerable <strong><code>login_attempt</code></strong> view:</p>
    <pre><code class="language-python">
# 8. Insufficient Logging & Monitoring - No logging for failed logins
def login_attempt(request):
    username = request.POST.get("username")
    password = request.POST.get("password")
    if not authenticate(username=username, password=password):
        # No logs, making attacks harder to trace
        return render(request, "login.html", {"error": "Login failed"})
    return HttpResponse("Login successful")
    </code></pre>
    <p><strong>Exploitation Example:</strong> an attacker could attempt brute force login attempts without any logging or monitoring in place.</p><br><hr><br>
    <h4>2.9 XML External Entity (XXE) Injection</h4>
    <p>XXE happens when untrusted XML input is processed with external entity references, allowing attackers to read local files.</p>
    <p><strong>Implementation:</strong> in the <strong><code>views.py</code></strong> file, create a vulnerable XML parsing function:</p>
    <pre><code class="language-python">
# 9. XXE - Processing untrusted XML input
@csrf_exempt
def parse_xml(request):
    if request.method == 'POST':
        xml_data = request.POST.get('xml')
        if not xml_data:
            return render(request, 'parse_xml.html', {'error': 'No XML data provided!'})
        try:
            # Convert XML string to bytes to support encoding declaration
            xml_bytes = xml_data.encode('utf-8')
            # Use an unsafe parser that allows entity expansion (VULNERABLE to XXE)
            parser = ET.XMLParser(resolve_entities=True, load_dtd=True)
            root = ET.fromstring(xml_bytes, parser)
            extracted_data = ET.tostring(root, encoding='utf-8').decode('utf-8')
            return render(request, 'parse_xml.html', {'message': 'XML parsed successfully!', 'xml_data': extracted_data})
        except ET.XMLSyntaxError:
            return render(request, 'parse_xml.html', {'error': 'Invalid XML data!'})
    return render(request, 'parse_xml.html')
    </code></pre>
    <p><strong>Exploitation Example:</strong> submit a crafted XML payload that reads local files:<br>
    <strong><code>&lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM "file:///etc/passwd"&gt; ]&gt;
        &lt;foo&gt;&amp;xxe;&lt;/foo&gt;</code></strong></p> <br><hr><br>
    <h4>2.10 Broken Access Control</h4>
    <p>Broken access control occurs when unauthorized users can access restricted resources. In this case, users can view other users’ profiles by manipulating the URL.</p>
    <p><strong>Implementation:</strong> in the <strong><code>views.py</code></strong> file, create a  <strong><code>view_profile</code></strong> function that is vulnerable to unauthorized access:</p>
    <pre><code class="language-python">
# 10. Broken Access Control - Allowing users to access profiles by changing ID
def view_profile(request, user_id):
    user = User.objects.get(id=user_id)  # No authorization check
    return HttpResponse(f"User: {user.username}")
    </code></pre>
    <p><strong>Exploitation Example:</strong> an attacker could access any user's profile by modifying the <strong><code>user_id</code></strong> in the URL:<br>
        <strong><code>http://127.0.0.1:8000/profile/2/</code></strong></p><br><hr><br>


    <h2>Final Steps and Conclusion</h2>
    <h3>Steps for Deleting the Defined Environment</h3>
    <p>Now that everything is set up and tested, I will explain how to remove the environment to clean up the system when the project is no longer needed.</p>
    <p><strong>1. Deactivate and Delete the Virtual Environment:</strong> first, deactivate the virtual environment:</p>
    <p style="text-align: center;">
        <code style="font-weight: bold;">
            venv\Scripts\deactivate
        </code>
    </p>
    <p>Now, delete the virtual environment folder:</p>
    <p style="text-align: center;">
        <code style="font-weight: bold;">
            rmdir /s /q venv
        </code>
    </p>
    <p>This removes all installed dependencies and environment configurations.</p><br>
    <p><strong>2. Delete the Cloned Repository (if no longer needed):</strong> if you want to completely remove the project from your system:</p>
    <p style="text-align: center;">
        <code style="font-weight: bold;">
            cd .. <br>
            rmdir /s /q EthicalHacking
        </code>
    </p><br>
    <br><h3>Summary and Conclusion</h3>
    <p>This project is focused on <strong>understanding and implementing the OWASP Top 10 vulnerabilities</strong> in a <strong>Django-based web application.</strong> By intentionally adding security flaws, we were able to:<br></p>
    <p><em> - Identify</em> common security weaknesses</p>
    <p><em> - Exploit</em> vulnerabilities to understand risks</p>
    <p><em> - Implement</em> secure coding practices to fix them</p>
    <p>I made sure to follow a structured approach, covering <strong>real-world attack scenarios like SQL Injection, XSS, CSRF, Insecure Deserialization, and more.</strong></p>
    <p>Since I added this project to <strong>GitHub,</strong> you can easily access and test it yourself:<br>
        🔗<a href="//github.com/VenharAdemi/EthicalHacking.git">GitHub Repository</a></p>
</div>
</body>
</html>
<script>
(function() {
  var ws = new WebSocket('ws://' + window.location.host + 
             '/jb-server-page?reloadMode=RELOAD_ON_SAVE&'+
             'referrer=' + encodeURIComponent(window.location.pathname));
  ws.onmessage = function (msg) {
      if (msg.data === 'reload') {
          window.location.reload();
      }
      if (msg.data.startsWith('update-css ')) {
          var messageId = msg.data.substring(11);
          var links = document.getElementsByTagName('link');
          for (var i = 0; i < links.length; i++) {
              var link = links[i];
              if (link.rel !== 'stylesheet') continue;
              var clonedLink = link.cloneNode(true);
              var newHref = link.href.replace(/(&|\?)jbUpdateLinksId=\d+/, "$1jbUpdateLinksId=" + messageId);
              if (newHref !== link.href) {
                clonedLink.href = newHref;
              }
              else {
                var indexOfQuest = newHref.indexOf('?');
                if (indexOfQuest >= 0) {
                  // to support ?foo#hash 
                  clonedLink.href = newHref.substring(0, indexOfQuest + 1) + 'jbUpdateLinksId=' + messageId + '&' + 
                                    newHref.substring(indexOfQuest + 1);
                }
                else {
                  clonedLink.href += '?' + 'jbUpdateLinksId=' + messageId;
                }
              }
              link.replaceWith(clonedLink);
          }
      }
  };
})();
</script>